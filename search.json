[
  {
    "objectID": "verotus.html",
    "href": "verotus.html",
    "title": "Verotus",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "href": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "title": "Verotus",
    "section": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa\nKuntaliitto käyttää kunnallisveron perustana kolmea ikäluokkaa. Ikäluokittelu huomioi palkansaajat ja eläkeläiset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - kolme ikäluokkaa\n\n0-18-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-18-vuotiaiden %-osuus oli 2024M07* yhteensä 16.05. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.43 (2022) ja -0.63 (2023)\n\n\n19-64-vuotiaat\n19-64-vuotiaiden palkansaajien %-osuus oli 2024M07* yhteensä 49.01. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.09 (2022) ja 0.37 (2023)\n\n\n65+-vuotiaat\n65+-vuotiaiden eläkeläisten prosenttiosuus kokonaisuudesta oli 2024M07* yhteensä 34.94. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.34 (2022) ja 0.26 (2023 )"
  },
  {
    "objectID": "verotus.html#ansiotulot",
    "href": "verotus.html#ansiotulot",
    "title": "Verotus",
    "section": "Ansiotulot",
    "text": "Ansiotulot\nTilasto sisältää tuloverotuksen valmistumisen mukaiset tiedot kaikista henkilöasiakkaista. Tilastossa ei huomioida muutosverotuksen tietoja. Lähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkkatulot\nPM %\nEläketulot\nEM %\nTyottomyysturva\nTM %\nMuut sos.turva\nMM %\nMaa- ja metsätalous\nMTM %\nElinkeinotoiminta\nELM %\nAnsiotulot\nAM %\n\n\n\n\n2014\n51,480\nNA\n29,489\nNA\n4,691\nNA\n2,135\nNA\n2,647\nNA\n6,501\nNA\n96,947\nNA\n\n\n2015\n48,282\n-6.21\n30,008\n1.76\n5,372\n14.52\n2,016\n-5.57\n2,201\n-16.85\n6,209\n-4.49\n94,091\n-2.95\n\n\n2016\n48,461\n0.37\n30,736\n2.43\n4,591\n-14.54\n2,009\n-0.35\n2,265\n2.91\n6,379\n2.74\n94,443\n0.37\n\n\n2017\n49,387\n1.91\n31,416\n2.21\n4,059\n-11.59\n1,916\n-4.63\n2,121\n-6.36\n5,992\n-6.07\n94,893\n0.48\n\n\n2018\n50,522\n2.30\n31,488\n0.23\n3,440\n-15.25\n1,808\n-5.64\n2,228\n5.04\n6,001\n0.15\n95,490\n0.63\n\n\n2019\n51,633\n2.20\n32,546\n3.36\n3,105\n-9.74\n1,840\n1.77\n2,283\n2.47\n6,257\n4.27\n97,667\n2.28\n\n\n2020\n50,130\n-2.91\n33,451\n2.78\n3,888\n25.22\n1,814\n-1.41\n1,986\n-13.01\n6,355\n1.57\n97,627\n-0.04\n\n\n2021\n51,836\n3.40\n33,532\n0.24\n3,911\n0.59\n1,968\n8.49\n1,898\n-4.43\n6,491\n2.14\n99,638\n2.06\n\n\n2022\n55,743\n7.54\n34,545\n3.02\n3,461\n-11.51\n2,081\n5.74\n2,112\n11.28\n5,540\n-14.65\n103,484\n3.86\n\n\n\n\n\n\n\n\nAnsiotulojen kehitys\nPalkkatulot olivat vuonna 2022 yhteensä 55,743. Muutos edelliseen 2021 vuoteen oli 7.54. Eläketulojen osalta muutos oli 3.02 (3.02)"
  },
  {
    "objectID": "verotus.html#vähennykset",
    "href": "verotus.html#vähennykset",
    "title": "Verotus",
    "section": "Vähennykset",
    "text": "Vähennykset\nTilaston vähennyseristä yleisesti: Jos verovelvolliselle ei ole määrätty verotettavasta tulosta veroja tai niiden määrä on pienempi kuin verosta myönnetty vähennys, myönnettyä vähennystä ei ole voitu vähentää kokonaisuudessaan. Tällaisissa tilanteissa verotuksessa vähennetty määrä on pienempi kuin myönnetty määrä. Sama periaate pätee myös tuloista tehtävien vähennysten osalta.\n*Lyhenteet:\n\nPV % = Palkansaajan vakuutusmaksujen %-osuus palkoista\n\nE % = Eläketulovähennyksen %-osuus eläkkeistä\n\nA % = Vuosittainen muutos ansiotulot-vähennykset*\nLähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkansaajan vak.maksut\nPV %\nVähennetyt matkakustan.\nMuut tulonhankk.vähenn.\nEläketulovähennys\nE %\nAnsiotulovähennys\nPerusvähennys\nMuut vähennykset\nVähennykset yht.\nVäh.aste\nAnsiotulot-vähennykset\nA %\n\n\n\n\n2014\n32,996\n7.02\n10,515\n14,740\n29,894\n20.78\n34,333\n13,521\n1,159\n137,158\n20.01\n548,401\nNA\n\n\n2015\n34,527\n7.20\n9,663\n15,031\n31,569\n21.34\n33,811\n14,496\n1,209\n140,305\n20.08\n558,317\n1.81\n\n\n2016\n37,558\n7.62\n9,287\n15,269\n31,180\n20.49\n33,660\n14,817\n1,096\n142,869\n19.94\n573,608\n2.74\n\n\n2017\n46,674\n9.22\n9,407\n17,463\n32,019\n20.25\n34,672\n15,623\n1,059\n156,917\n21.42\n575,774\n0.38\n\n\n2018\n51,373\n9.63\n10,193\n17,864\n31,643\n19.43\n35,250\n16,020\n1,076\n163,418\n21.46\n598,104\n3.88\n\n\n2019\n53,812\n9.62\n10,487\n18,326\n31,213\n18.49\n35,593\n17,848\n1,071\n168,349\n21.25\n624,002\n4.33\n\n\n2020\n52,738\n9.44\n9,383\n18,754\n31,925\n18.16\n34,895\n20,412\n1,174\n169,282\n21.00\n636,792\n2.05\n\n\n2021\n57,807\n9.72\n9,954\n19,457\n32,234\n17.85\n35,216\n21,438\n1,109\n177,215\n20.92\n669,775\n5.18\n\n\n2022\n61,446\n9.61\n12,921\n19,888\n34,528\n18.46\n36,330\n22,239\n1,101\n188,453\n21.02\n708,271\n5.75"
  },
  {
    "objectID": "verotus.html#kiinteistövero",
    "href": "verotus.html#kiinteistövero",
    "title": "Verotus",
    "section": "Kiinteistövero",
    "text": "Kiinteistövero\nKunnan alueella sijaitsevista kiinteistöistä maksuunpantu kiinteistövero tilitetään kokonaisuudessaan kyseiselle kunnalle. Tilaston avulla voi arvioida kunnan kiinteistöverotuottojen suuruutta. Tilastoluvut eivät kuitenkaan kerro aivan tarkasti kunnille todellisuudessa tilitetyistä kiinteistöverotuotoista, koska maksuunpannun kiinteistöveron määrä voi muuttua muutosverotuksen myötä ja nämä muutokset eivät päivity tilastolukuihin. Lisäksi maksuunpantua kiinteistöveroa ei välttämättä saada kokonaisuudessaan kerättyä. Lähde: (Vero.fi 2024b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKiinteistöverojen kehitys\nKiinteistöverojen määrä oli vuonna 2024 (ennakkotieto) yhteensä 1,901,502. Muutos edelliseen vuoteen 2023 oli 1.95."
  },
  {
    "objectID": "tyollisyys.html",
    "href": "tyollisyys.html",
    "title": "Työllisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "href": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "title": "Työllisyys",
    "section": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa",
    "text": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa\n\n\n\n\n\n\n\n\n\n\nVertailu koko maan ja maakunnan osalta\nUrjala on sijalla 220, tarkasteltaessa työttömien työnhakijoiden %-osuutta työvoimasta. Viimeisin ennakkotietolukema on 11. Maakuntavertailussa (Pirkanmaa) Urjala on sijalla 19."
  },
  {
    "objectID": "tyollisyys.html#työttömät-työnhakijat",
    "href": "tyollisyys.html#työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Työttömät työnhakijat",
    "text": "Työttömät työnhakijat\n\nTyöttömät työnhakijat laskentapäivänä\n\n\n\n\n\n\nTilastokeskuksen työssäkäyntitilaston mukaan työttömiä työnhakijoita oli 2024M07 yhteensä 208 (lukema 2024M06: 197)."
  },
  {
    "objectID": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "href": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Alle 25-v. työttömät työnhakijat",
    "text": "Alle 25-v. työttömät työnhakijat\n\n\n\n\n\n\n:::\n\nAlle 25-v. työttömät työnhakijat (lkm.)\nAlle 25-vuotiaita työttömiä oli 2024M07 yhteensä 12 (lukema 2024M06: 15)."
  },
  {
    "objectID": "muuttoliike.html",
    "href": "muuttoliike.html",
    "title": "Muuttoliike",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\n\n\n\n\n\n\n\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}\n\n\n\n\n\n\n\nMuuttoliike\n\n\nKuntien välinen muuttoliike\nYmpyrä kuvaa kuntien välistä muuttoliikettä. Vihreällä olevat kunnat ovat muuttovoittajien ja punaisella olevat häviäjiä. Siniset viivat ympyrän keskellä kuvaavat muuttovirtojen suuruutta. Voit zoomata ympyrää hiiren rullalla. Laittamalla hiiren osoitin kuvan päälle näet muuttojen suuruudet ja liikesuunnat.\n\ndata = (await FileAttachmentDynamic(migrationChordCSV).csv());\n\n\nchart_chord_d3(data, title_txt_chord,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_chord_d3(data, title_txt_chord,chart_width,chart_height)), title_txt_chord, \"Save as SVG\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Alkusanat",
    "section": "",
    "text": "Alkusanat\nKuukausiraportti tarjoaa tietoa väestöstä, työmarkkinoista, asumisesta, rakentamisesta ja taloudesta kuukausi tai neljännesvuositasolla. Tietolähteinä käytetään esimerkiksi Tilastokeskuksen ja Verohallinon tilastoaineistoa. Kuukausiraporttia kehitetään yhteistyössä kuntien kanssa.\nRaportti on ajettu syyskuussa, 2024\nRaportti on julkaistu (GNU.org 2024) lisenssin alla. Kuukausiraportti on html-muodossa. Malleja kuntakohtaisesta raporteista löytyy osoitteista:\n\nKangasala: https://kangasalakehitys.github.io/kuukausiraportti/\nAkaa: https://kangasalakehitys.github.io/akaa/\nJuupajoki: https://kangasalakehitys.github.io/juupajoki/\nKuhmoinen: https://kangasalakehitys.github.io/kuhmoinen/\nMasku: https://kangasalakehitys.github.io/masku/\nNousinen: https://kangasalakehitys.github.io/nousiainen/\nPälkäne: https://kangasalakehitys.github.io/palkane/\nParkano: https://kangasalakehitys.github.io/parkano/\nUrjala: https://kangasalakehitys.github.io/urjala/\nYlöjärvi: https://kangasalakehitys.github.io/ylojarvi/\n\n\n\n\n\n\nLähteet\n\nGNU.org. 2024. LGPL 2.1 lisenssi. GNU.org. https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html."
  },
  {
    "objectID": "aluetalous.html",
    "href": "aluetalous.html",
    "title": "Aluetalous ja yritystoiminta",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "href": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Aloittaneet ja lopettaneet yritykset",
    "text": "Aloittaneet ja lopettaneet yritykset\n\n\n\n\n\n\n\nAloittaneet ja lopettaneet yritykset\nAloittaneita yrityksiä ajanjaksolla 2024Q1 oli yhteensä 9 (lukema 2023Q4: 3). . Lopettaneiden yritysten määrä oli samalla ajanjaksolla yhteensä 5 (lukema 2023Q4: 4).."
  },
  {
    "objectID": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "href": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)",
    "text": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M07 yhteensä 6 (lukema 2024M06: 8)."
  },
  {
    "objectID": "aluetalous.html#uudet-avoimet-työpaikat",
    "href": "aluetalous.html#uudet-avoimet-työpaikat",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Uudet avoimet työpaikat",
    "text": "Uudet avoimet työpaikat\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M07 yhteensä 8 (lukema 2024M06: 7)."
  },
  {
    "objectID": "asuminen.html",
    "href": "asuminen.html",
    "title": "Asuminen",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypeittäin",
    "text": "Asuminen - Asuntokunnat talotyypeittäin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTalotyyppien %-osuudet asuntokunnissa\nAsuntokunnista 2024Q2* omakoti- ja paritaloissa asui 70.5 % (edell. 70.6). Rivitaloissa asuvien osuus oli 17.5% (edell. 17.4) ja kerrostaloissa 9.8% (edell. 9.8)."
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypin ja koon mukaan",
    "text": "Asuminen - Asuntokunnat talotyypin ja koon mukaan"
  },
  {
    "objectID": "kansainvalisyys.html",
    "href": "kansainvalisyys.html",
    "title": "Kansainvälisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "href": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "title": "Kansainvälisyys",
    "section": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto",
    "text": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto\n\n\n\n\n\n\n\nMaahanmuutto ja nettomaahanmuutto\nKumulatiivinen nettomaahanmuutto oli vuoden alusta tähän hetkeen 2024M07* yhteensä 3. Edellisvuoden lukema nettomaahanmuutossa oli 28. Erotusta nettomaahanmuutossa viime vuoteen on yhteensä -25 henkilöä. Pohjoismaista oli muuttanut yhteensä yhteensä 1 henkilöä ja muista EU-maista 1 henkilöä. Kokonaisuudessaan maahanmuuttajia oli yhteensä 8.\nNettomaahanmuutto (tai nettosiirtolaisuus) on maahanmuuton ja maastamuuton erotus. Lähde: Tilastokeskus"
  },
  {
    "objectID": "syntyvyys.html",
    "href": "syntyvyys.html",
    "title": "Syntyvyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "syntyvyys.html#luonnollinen-väestönkasvu",
    "href": "syntyvyys.html#luonnollinen-väestönkasvu",
    "title": "Syntyvyys",
    "section": "Luonnollinen väestönkasvu",
    "text": "Luonnollinen väestönkasvu\n\nLuonnollinen väestönlisäys\n\n\n\n\n\n\nSyntyneiden enemmyys eli luonnollinen väestönlisäys tarkoittaa elävänä syntyneiden ja kuolleiden erotusta.\nLuonnollinen väestönlisäys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä -22 (2024Q1*: -11). Vuosina 2022 ja 2023 luonnollinen väestönlisäys oli 2022: -54 ja 2023: -44"
  },
  {
    "objectID": "syntyvyys.html#syntyneet",
    "href": "syntyvyys.html#syntyneet",
    "title": "Syntyvyys",
    "section": "Syntyneet",
    "text": "Syntyneet\n\nSyntyvyys\n\n\n\n\n\n\n\n\nSyntyvyys\nSyntyvyys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä 15 (lukema 2024Q1* oli 8). Vuosina 2022 ja 2023 syntyvyys oli lukemissa (2022) 24 ja (2023) 30."
  },
  {
    "objectID": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "href": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "title": "Syntyvyys",
    "section": "Väestönmuutokset - Väestöpyramidi",
    "text": "Väestönmuutokset - Väestöpyramidi\n\nDOM.download(() =&gt; serialize(pyramid), \"Väestöpyramidi\", \"Save as SVG\")\n\n\n\n\n\n\n\npyramid_pop_data = FileAttachmentDynamic(pyramid_pop_csv).csv({typed: true})\n\ntranslations = ({\n  v1990: \"1990\",\n  v2010: \"2010\",\n  v2024: valitut_kk_tahti\n  })\n\npyramid = toSVG(Plot.plot({\n  width: 600,\n  height: 600,\n  marginTop: 20,\n  marginRight: 20,\n  marginBottom: 30,\n  marginLeft: 40,\n  x: {\n    label: \"← mies · väestö · nainen →\",\n    labelAnchor: \"center\",\n    tickFormat: Math.abs,\n    //domain: [-300, 300]\n  },\n  y: {grid: true},\n  color: {\n    width: 300,\n    domain: [\"v1990\", \"v2010\", \"v2024\"],\n    range: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n    legend: true,\n    className: 'large-font',\n    tickFormat: (d) =&gt; translations[d]\n  },\n  style: {\n    fontSize: 14\n  },\n  marks: [\n    Plot.lineX(pyramid_pop_data, {\n      x: (d) =&gt; d.population * (d.sex === \"Miehet\" ? -1 : 1),\n      y: \"age\",\n      z: (d) =&gt; [d.sex, d.category].join(\",\"),\n      stroke: \"category\",\n      strokeWidth: 4,\n      fill: \"category\",\n      fillOpacity: 0\n    }),\n    Plot.ruleX([0]),\n    Plot.ruleY([0])\n  ]\n}))"
  },
  {
    "objectID": "vaesto.html",
    "href": "vaesto.html",
    "title": "Väestönmuutokset",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "href": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "title": "Väestönmuutokset",
    "section": "Kuntien välinen nettomuutto - viimeiset 12kk",
    "text": "Kuntien välinen nettomuutto - viimeiset 12kk\nVoit tarkistella karttaa tarkemmin pyörittämällä hiiren rullanäppäintä.\n\ndata_migr = (await FileAttachmentDynamic(migrBetwMuniMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\nmapInterpolateRdBu_migr = d3.scaleDiverging([-150, 0, 150], d3.interpolatePiYG);\n\nborderColorDark_migr = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)), title_txt_map_migr, \"Save as SVG\")\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk\n\n\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk, top20\nUrjala on sijalla 180, tarkasteltaessa kuntien välistä nettomuuttoa viimeisen 12kk aikana. Kuntien välinen nettomuuttolukema on -28. Maakuntavertailussa (Pirkanmaa) Urjala on sijalla 14."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko",
    "href": "vaesto.html#väestönmuutokset---väestöennakko",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko",
    "text": "Väestönmuutokset - Väestöennakko\n\n\n\n\n\n\n\nEnnakkotiedot\nEnnakkotietojen (2024M07) perusteella Kangasalan väkiluku on laskenut -0.07 %. (2024M06: 0 %). Uusin väestön ennakkotieto on 4536 (edell. lukema 4539). Vuoden alusta (2023: 4568) väkiluku on laskenut -0.7 %."
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% vuoden 2023 lopusta",
    "text": "Väkiluvun muutos-% vuoden 2023 lopusta\nVoit tarkistella kartaa lähemmin pyörittämällä hiiren rullanäppäintä.\n\ndata = (await FileAttachmentDynamic(populationMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\n//mapInterpolateRdBu = d3.scaleDiverging([domain_min, 0, domain_max], d3.interpolateRdBu);\nmapInterpolateRdBu = d3.scaleDiverging([-1.5, 0, 1.5], d3.interpolatePiYG);\n\nborderColorDark = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)), title_txt_map, \"Save as SVG\")"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% edellisvuoden lopusta",
    "text": "Väkiluvun muutos-% edellisvuoden lopusta\n\n\n\n\n\n\n\n\n\n\nVäkiluvun muutos-% edellisvuoden lopusta\nUrjala on sijalla 252, tarkasteltaessa väkiluvun muutosta edellisvuoden lopusta kuntien kesken. Viimeisin ennakkotietolukema on 4536 (muutos-% edellisen vuoden loppuun: -0.7). Maakuntavertailussa (Pirkanmaa) Urjala on sijalla 17."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 5 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M07* yhteensä 4.45. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.3 (2022) ja -0.28 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M07* yhteensä 8.53. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.27 (2022) ja -0.12 (2023)\n\n\n16-64-vuotiaat\nIkäluokka 16-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M07* yhteensä 52.07. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.22 (2022) ja 0.12 (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M07* yhteensä 25.09. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.01 (2022) ja -0.02 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M07* yhteensä 9.85. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.33 (2022) ja 0.28 (2023)"
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 6 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M07* yhteensä 4.45. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.3 (2022) ja -0.28 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M07* yhteensä 8.53. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.27 (2022) ja -0.12 (2023)\n\n\n16-18-vuotiaat\n16-18-vuotiaiden prosenttiosuus kokonaisuudesta oli 2024M07* yhteensä 3.06. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.13 (2022) ja -0.25 (2023)\n\n\n18-64-vuotiaat\nIkäluokka 18-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M07* yhteensä 52.07. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut **** (2022) ja **** (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M07* yhteensä 25.09. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.01 (2022) ja -0.02 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M07* yhteensä 9.85. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.33 (2022) ja 0.28 (2023)"
  }
]